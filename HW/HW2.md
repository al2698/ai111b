## 注意事項

- 程式碼聲明
  本作業的程式碼是參考老師的Code 和 ChatGPT。

---
# 旅行推銷員 TSP 問題

> 程式碼：[ipynb](./HW2.ipynb)

```py
import math
import random

def distance(a, b):
    """
    計算兩點之間的距離
    :param a: 點A的座標 (x, y)
    :param b: 點B的座標 (x, y)
    :return: 兩點之間的距離
    """
    dx = a[0] - b[0]
    dy = a[1] - b[1]
    return math.sqrt(dx ** 2 + dy ** 2)

def reverse_segment(tour, i, j):
    """
    對一個圓形的子序列進行翻轉
    :param tour: 旅行推銷員的路徑
    :param i: 子序列的起始點的索引
    :param j: 子序列的終點的索引
    :return: 翻轉後的路徑
    """
    while i < j:
        tour[i], tour[j] = tour[j], tour[i]
        i += 1
        j -= 1
    return tour

def tsp_solver(points):
    """
    使用2-opt方法解決旅行推銷員問題
    :param points: 輸入的點的座標列表，每個點的座標為 (x, y)
    :return: 最佳路徑的座標列表，最短路徑的長度
    """
    n = len(points)
    tour = list(range(n))  # 初始路徑為順序訪問所有點
    best_tour = tour[:]  # 最佳路徑的複製
    best_length = float('inf')  # 最短路徑的初始值設為無窮大

    improvement = True
    while improvement:
        improvement = False
        for i in range(1, n - 2):
            for j in range(i + 1, n):
                if j - i == 1:  # 子序列不能只有相鄰的兩個點
                    continue
                new_tour = tour[:]
                new_tour = reverse_segment(new_tour, i, j)  # 對子序列進行翻轉
                new_length = sum(distance(points[new_tour[k]], points[new_tour[k + 1]]) for k in range(n - 1))
                if new_length < best_length:
                    best_tour = new_tour[:]
                    best_length = new_length
                    improvement = True

        tour = best_tour

    return [points[i] for i in best_tour], best_length

# 測試資料
points = [(0, 0), (1, 1), (2, 2), (3, 3), (1, 0), (0, 1), (1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2)]

best_path, best_length = tsp_solver(points)
print("Best Path:", best_path)
print("Best Length:", best_length)

```
## 原理的解釋
這段程式碼使用了2-opt方法解決旅行推銷員問題，以下是原理的解釋：

1. 初始化：程式首先將所有點的座標儲存在一個列表中，並初始化一個順序路徑 `tour`，該路徑按照點在列表中的順序訪問。

2. 主要迴圈：程式使用一個主要的迴圈來改進路徑，直到不再有改進為止。

3. 子序列翻轉：在每個迴圈中，程式遍歷所有的點對 `(i, j)`，其中 `i` 是子序列的起始點的索引，`j` 是子序列的終點的索引。子序列必須至少包含 3 個點，因為只有兩個相鄰的點進行翻轉沒有意義。

4. 翻轉操作：對於選定的子序列，程式使用 `reverse_segment` 函數將該子序列進行翻轉。該函數通過交換子序列中的點來實現翻轉，從而改變路徑的訪問順序。

5. 路徑長度計算：在進行翻轉後，程式計算新路徑的長度。它遍歷新路徑中的每個相鄰點對，並使用 `distance` 函數計算它們之間的距離。然後將這些距離相加，得到新路徑的長度 `new_length`。

6. 改進判斷：如果新路徑的長度 `new_length` 比當前最佳路徑的長度 `best_length` 還要短，則將最佳路徑 `best_tour` 更新為新路徑，同時更新最佳路徑的長度 `best_length`。並將改進標誌 `improvement` 設置為 `True`。

7. 更新路徑：將路徑 `tour` 更新為最佳路徑 `best_tour`。

8. 迴圈結束：如果在一次迴圈中沒有改進，則 `improvement` 保持為 `False`，主要迴圈結束。

9. 輸出結果：最終，程式返回最佳路徑的座標列表 `best_path` 和最短路徑的長度 `best_length`。

這裡有一個示例來說明原理。假設有 6 個點

的座標如下：

```
points = [(0, 0), (1, 1), (2, 2), (3, 3), (1, 0), (0, 1)]
```

初始路徑 `tour` 為順序訪問所有點的路徑：`[0, 1, 2, 3, 4, 5]`。根據算法，它會選擇子序列 `(1, 2, 3)` 並進行翻轉，將該子序列變為 `(1, 3, 2)`。然後計算新路徑的長度，如果比最佳路徑的長度更短，則更新最佳路徑。程式重複進行這些步驟，直到沒有改進為止。

輸出結果可能如下：

```
Best Path: [(0, 0), (1, 0), (0, 1), (1, 1), (2, 2), (3, 3)]
Best Length: 6.242640687119285
```

## 2-opt和爬山算法
2-opt和爬山算法是兩種常用的優化算法，用於解決旅行推銷員問題和其他優化問題。以下是它們之間的差異以及各自的優缺點：

2-opt算法：
- 原理：2-opt算法通過交換路徑中的兩條邊，來改進路徑的長度。它通常使用一個迴圈來尋找可以改進的邊對，並進行交換。經過多次迴圈，直到無法找到更短的路徑為止。
- 優點：
  - 簡單而直觀：2-opt算法的實現相對簡單，易於理解和實現。
  - 可應用於大型問題：2-opt算法的時間複雜度較低，對於較大的問題規模也能獲得合理的解。
- 缺點：
  - 局部最優解：2-opt算法只進行局部改進，容易陷入局部最優解而無法找到全局最優解。
  - 收斂速度慢：2-opt算法的收斂速度較慢，特別是在問題規模較大時，需要多次迴圈才能達到較好的結果。

爬山算法：
- 原理：爬山算法是一種局部搜索算法，它通過尋找鄰近解並比較它們的評估函數值，從而逐步向更好的解移動。它始於一個隨機生成的解，然後尋找該解的鄰近解中最好的解作為下一步的候選解。重複這個過程，直到無法找到更好的解為止。
- 優點：
  - 局部搜索：爬山算法能夠在局部搜索空間中快速找到較好的解，特別適用於在短時間內找到合理解的情況。
  - 容易實現：爬山算法的實現相對簡單，不需要很多複雜的參數和設定。
- 缺點：
  - 容易陷入局部最優解：由於爬山算法只考慮鄰近解，容易陷入局部最優解而無法找到全局最優解。
  - 初始解的重要

性：爬山算法的結果受初始解的影響較大，如果初始解不佳，可能會陷入局部最優解並難以跳出。

總結來說，2-opt算法是一種全局搜索算法，優點是易於實現和應用於大型問題，但收斂速度相對較慢，容易陷入局部最優解。爬山算法是一種局部搜索算法，優點是在局部搜索空間中能夠快速找到較好的解，但也容易陷入局部最優解，對初始解的選擇敏感。選擇哪種算法取決於問題的規模和性質，以及需要求解的最佳解的要求。在實際應用中，常常需要結合多種算法和技術來獲得更好的結果。